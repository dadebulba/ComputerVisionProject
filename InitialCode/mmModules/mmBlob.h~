/*
 * mmBlob.h
 *
 *  Created on: Nov 24, 2010
 *      Author: paolo
 */

#ifndef MMBLOB_H_
#define MMBLOB_H_

using namespace cv;

namespace mmLib {
namespace mmModules{

enum BLOB_TYPE{
	STANDARD,MERGE,NEW,SPLIT,NONVISIBLE,
};

class mmBlob {
public:
	mmBlob();
	mmBlob(Mat frame, Point tl, Size sz);
	mmBlob(Mat frame, int x, int y, int w, int h);
	mmBlob(Mat frame, vector<Point> ptList);
	virtual ~mmBlob();

	// Ritorna il punto centrale del blob
	Point centroid();

	// ritorna img
	Mat getBlob();

	// foreground
	Mat getFgnd();
	bool isFgdnSet;
	void setFgnd(Mat f);

	// M
//	Mat getAppM();
//	bool isAppMSet;
//	void setAppM(Mat f);

	// prob
//	Mat getAppP();
//	bool isAppPSet;
//	void setAppP(Mat f);

	// Ritorna il rect con le coordinate del blob
	Rect boundingBoxProcessed();
	Rect boundingBoxProcessedRefined(Mat frame);
	Point getTL();
	Point getBR();
	int getBlobArea();
	int getWidth();
	int getHeight();

	bool isConteined(Point pt);
//	bool isConteinedMod(Point pt);

	// Just for colored images get the array of float[256] normalized
	void getBins(float* histBlue, float* histGreen, float* histRed);

	int blobID;
	float assignedMSE;
	vector<int> bindedKalman;
	void pushPoint(Point p);
	BLOB_TYPE type;

	////////////
	Scalar chooseColor(mmBlob blob);
	vector<Point> centList;
	int depth;
	Scalar color;
	Point dispVect;
	Size mergeDimension;
	void setPointList(vector<Point> pList);
	vector<Point> getPointList();
	void setB(Mat mat);
	void setG(Mat mat);
	void setR(Mat mat);
	void setP(Mat mat);
	Mat getB();
	Mat getG();
	Mat getR();
	Mat getP();
	void setContourPoints(vector<Point> vP);
	vector<Point> getContourPoints();
	Mat getBlobPointsAsMat(Mat frame);
	//////////
private:

	// Makes a cut of the frame on the blob
	Mat blobBuilder(Mat frame);

	vector<Point> pointList;
	vector<Point> contourPoints;
	Mat fgd;
	Mat img;
	Mat B;
	Mat R;
	Mat G;
	Mat prob;
	int coordX;
	int coordY;
	int width;
	int height;
};

// Other useful functions
Mat mmDrawBlobs(Mat img, vector<mmBlob> blobList);
void mmShowHistogram(float* hist, String wName);
float mmHistogramMatchingMSE(float* histA, float* histB);
//float mmFullHistMatching(Mat a, Mat b);
float test_matching(Mat matA, Mat matB);
void my_hist (Mat image, float* histBlue, float* histGreen, float* histRed);
float HistogramMatching(float* histA, float* histB);
void HistogramMatching_v2 (Mat a, Mat b, float * Hred, float * Hblue, float * Hgreen);
float test_matching_v2(Mat matA, Mat backgroundA, Mat matB, Mat backgroundB);

//Ritorna i punti del fg contenuti nel blob
Mat mmDrawBlobsAndPoints(Mat img, Mat foreground, vector<mmBlob> blobList);
Mat mmDrawPoints(Mat img,Mat foreGray, vector<mmBlob> blobList);
Mat mmDrawBlobInAndOut(Mat img,vector<mmBlob> blobListIn,vector<mmBlob> blobListOut);
Mat mmPrintTrack(Mat img, vector<mmBlob> blobList);
//Mat mmDrawBlobFromStruct(Mat img,vector<mmLib::mmModules::blobListModule> *blobIn,vector<mmLib::mmModules::blobListModule> *blobOut);
int getDist(mmBlob blob1, mmBlob blob2);
int getDistFrmBlob(mmBlob blob,Point p);
Scalar assignRandomColor();
bool isPointList(mmBlob blob, Point p);
//void saveCent(vector<mmBlob> blobList);
}
}
#endif /* MMBLOB_H_ */

