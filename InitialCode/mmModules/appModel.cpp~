#include "../mmLib.h"

namespace mmLib {
	namespace mmModules{
	appModel::appModel(){
		alpha = 0.95;
		lambda = 0.95;
		sigma = 0.5;
		thresh = 0.03;
		totalFrameProcessed =-1;
	}

	appModel::appModel(double a, double l, double s, double th, int tfp){
		alpha = a;
		lambda = l;
		sigma = s;
		thresh = th;
		totalFrameProcessed = tfp;
	}

//	appModel::~appModel(){
//
//	}

	void appModel::appFrame(){
		totalFrameProcessed++;
	}

	mmBlob appModel::newAppModel(Mat frame,Mat foreground,mmBlob blob){
		uchar* pr = frame.ptr<uchar>(0);

		Mat B(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat R(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat G(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat prob(frame.rows,frame.cols,CV_32F,cv::Scalar(0));

		for (int i=blob.getTL().x; i<=blob.getBR().x; i++){
			for (int j=blob.getTL().y; j<=blob.getBR().y; j++){
				Point p = Point(i,j);
				int index = (j*frame.cols+i);

				float Bi = (float)pr[3*index];
				float Gi = (float)pr[3*index+1];
				float Ri = (float)pr[3*index+2];

				if (isFg(foreground,p)){
					B.at<float>(j,i) = Bi;
					G.at<float>(j,i) = Gi;
					R.at<float>(j,i) = Ri;
					prob.at<float>(j,i) = 0.4;
				}
			}
		}
		blob.setB(B);
		blob.setG(G);
		blob.setR(R);
		blob.setP(prob);

		return blob;
	}

	mmBlob appModel::stdAppModel(Mat frame, Mat foreground, mmBlob blobNew, mmBlob blobOld){
		uchar* pr = frame.ptr<uchar>(0);

		Mat B(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat R(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat G(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat prob(frame.rows,frame.cols,CV_32F,cv::Scalar(0));

		for (int i=blobNew.getTL().x; i<=blobNew.getBR().x; i++){
			for (int j=blobNew.getTL().y; j<=blobNew.getBR().y; j++){
				Point p = Point(i,j);
				int index = (j*frame.cols+i);

				float Bi = (float)pr[3*index];
				float Gi = (float)pr[3*index+1];
				float Ri = (float)pr[3*index+2];

				if (isFg(foreground,p)){
					B.at<float>(j,i) = alpha*blobOld.getB().at<float>(j,i) + (1-alpha)*Bi;
					G.at<float>(j,i) = alpha*blobOld.getG().at<float>(j,i) + (1-alpha)*Gi;
					R.at<float>(j,i) = alpha*blobOld.getR().at<float>(j,i) + (1-alpha)*Ri;
					prob.at<float>(j,i) = lambda*blobOld.getP().at<float>(j,i) + (1-lambda);
				}
				else{
					prob.at<float>(j,i) = lambda*blobOld.getP().at<float>(j,i);
				}
			}
		}
		blobNew.setB(B);
		blobNew.setG(G);
		blobNew.setR(R);
		blobNew.setP(prob);

		return blobNew;
	}

	mmBlob appModel::mergeAppModel(Mat frame, Mat foreground, mmBlob blobNew, mmBlob blobOld){
		uchar* pr = frame.ptr<uchar>(0);

		Mat B(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat R(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat G(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat prob(frame.rows,frame.cols,CV_32F,cv::Scalar(0));

		vector<Point> vectPoint = blobNew.getPointList();
		for (int i=0; i<vectPoint.size(); i++){
			Point p = Point(vectPoint[i].x,vectPoint[i].y);
			int index = (p.y*frame.cols+p.x);

			float Bi = (float)pr[3*index];
			float Gi = (float)pr[3*index+1];
			float Ri = (float)pr[3*index+2];

			if (isFg(foreground,p)){
				B.at<float>(p.y,p.x) = alpha*blobOld.getB().at<float>(p.y,p.x) + (1-alpha)*Bi;
				G.at<float>(p.y,p.x) = alpha*blobOld.getG().at<float>(p.y,p.x) + (1-alpha)*Gi;
				R.at<float>(p.y,p.x) = alpha*blobOld.getR().at<float>(p.y,p.x) + (1-alpha)*Ri;
				prob.at<float>(p.y,p.x) = lambda*blobOld.getP().at<float>(p.y,p.x) + (1-lambda);
			}
			else{
				prob.at<float>(p.y,p.x) = lambda*blobOld.getP().at<float>(p.y,p.x);
			}
		}
		blobNew.setB(B);
		blobNew.setG(G);
		blobNew.setR(R);
		blobNew.setP(prob);

		return blobNew;
	}

	mmBlob appModel::nonMergeAppModel(Mat frame, Mat foreground, mmBlob blobNew, vector<mmBlob> blobOld){
		uchar* pr = frame.ptr<uchar>(0);

		Mat B(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat R(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat G(frame.rows,frame.cols,CV_32F,cv::Scalar(0));
		Mat prob(frame.rows,frame.cols,CV_32F,cv::Scalar(0));

		for (int i=blobNew.getTL().x; i<=blobNew.getBR().x; i++){
			for (int j=blobNew.getTL().y; j<=blobNew.getBR().y; j++){
				Point p = Point(i,j);
				int index = (j*frame.cols+i);

				float Bi = (float)pr[3*index];
				float Gi = (float)pr[3*index+1];
				float Ri = (float)pr[3*index+2];

				for(int k=0; k<blobOld.size(); k++){
					prob.at<float>(j,i) = prob.at<float>(j,i) + lambda*blobOld[k].getP().at<float>(j,i);
					if (isFg(foreground,p)){
						B.at<float>(j,i) = B.at<float>(j,i) + alpha*blobOld[k].getB().at<float>(j,i);
						G.at<float>(j,i) = G.at<float>(j,i) + alpha*blobOld[k].getG().at<float>(j,i);
						R.at<float>(j,i) = R.at<float>(j,i) + alpha*blobOld[k].getR().at<float>(j,i);
					}
				}
				if (isFg(foreground,p)){
					B.at<float>(j,i) = B.at<float>(j,i) + (1-alpha)*Bi;
					G.at<float>(j,i) = G.at<float>(j,i) + (1-alpha)*Gi;
					R.at<float>(j,i) = R.at<float>(j,i) + (1-alpha)*Ri;
					prob.at<float>(j,i) = prob.at<float>(j,i)  + (1-lambda);
				}
			}
		}
		blobNew.setB(B);
		blobNew.setG(G);
		blobNew.setR(R);
		blobNew.setP(prob);

		return blobNew;
	}

	//MOD
	Mat appModel::getAppMatrix(Mat frame, mmBlob blob){
		int nRows = frame.rows;
		int nCols = frame.cols;

		Mat ret(nRows,nCols,CV_8UC3,cv::Scalar(0));

		for (int i=blob.getTL().x; i<blob.getBR().x; i++){
			for (int j = blob.getTL().y; j < blob.getBR().y; j++){
				int index = nCols*i+j;
				ret.at<uchar>(j,3*i)   = (uchar)blob.getB().at<float>(j,i);
				ret.at<uchar>(j,3*i+1) = (uchar)blob.getG().at<float>(j,i);
				ret.at<uchar>(j,3*i+2) = (uchar)blob.getR().at<float>(j,i);
			}
		}

		return ret;
	}

	//MOD
	Mat appModel::getProbMatrix(Mat frame, mmBlob blob){
		int nRows = frame.rows;
		int nCols = frame.cols;

		Mat ret(nRows,nCols,CV_8U,cv::Scalar(0));

		for (int i=blob.getTL().x; i<blob.getBR().x; i++){
			for (int j = blob.getTL().y; j < blob.getBR().y; j++){
				int index = nCols*i+j;
				ret.at<uchar>(j,i) = blob.getP().at<float>(j,i)*255;
			}
		}

		return ret;
	}

	vector<mmBlob> appModel::predictPosition(Mat frame, mmBlob blob, vector<mmBlob> tracks, vector<int> idxTracks){
		vector<mmBlob> result;
		bool isFirstMerge = false;

		for(int i=0; i<tracks.size(); i++){
			if (tracks[i].depth == 0){
				isFirstMerge = true;
			}
		}

		for(int i=0; i<tracks.size(); i++){
			int tx = (tracks[i].getTL().x+tracks[i].dispVect.x >= 0)?tracks[i].getTL().x+tracks[i].dispVect.x:0;
			int ty = (tracks[i].getTL().y+tracks[i].dispVect.y >= 0)?tracks[i].getTL().y+tracks[i].dispVect.y:0;
			int bx = (tracks[i].getBR().x+tracks[i].dispVect.x < frame.cols)?tracks[i].getBR().x+tracks[i].dispVect.x:frame.cols-1;
			int by = (tracks[i].getBR().y+tracks[i].dispVect.y < frame.rows)?tracks[i].getBR().y+tracks[i].dispVect.y:frame.rows-1;
			result.push_back(mmBlob(frame,Point(tx,ty),Size(bx-tx,by-ty)));
			result[i].depth = tracks[i].depth;
			result[i].dispVect = tracks[i].dispVect;
			result[i].mergeDimension = (isFirstMerge == true)?Size(bx-tx,by-ty):tracks[i].mergeDimension;
			result[i].setB(tracks[i].getB());
			result[i].setG(tracks[i].getG());
			result[i].setR(tracks[i].getR());
			result[i].setP(tracks[i].getP());
		}

		return result;
	}

	mmBlob appModel::propagateObject(Mat frame, Mat foreground, mmBlob track){
		mmBlob result;
		vector <Point> pRes;

		int tx = (track.getTL().x+track.dispVect.x >=0)?track.getTL().x+track.dispVect.x:0;
		int ty = (track.getTL().y+track.dispVect.y >=0)?track.getTL().y+track.dispVect.y:0;
		int bx = (track.getBR().x+track.dispVect.x < frame.cols)?track.getBR().x+track.dispVect.x:frame.cols-1;
		int by = (track.getBR().y+track.dispVect.y < frame.rows)?track.getBR().y+track.dispVect.y:frame.rows-1;

		for (int i=tx; i<=bx; i++){
			for (int j=ty; j<=by; j++){
				Point p = Point(i,j);

				if (isFg(foreground,p)){
					Point pOld = Point(i-track.dispVect.x,j-track.dispVect.y);
					double pRGB = getPrgb(frame, track, p, pOld);
					double Pci = (double)track.getP().at<float>(pOld.y,pOld.x);
					double pi = pRGB*Pci;

					if (pi>thresh){
						pRes.push_back(p);
					}
				}
			}
		}
		if (pRes.empty()){
			result = mmBlob();
		}
		else{
			result = mmBlob(frame,Point(tx,ty),Size(bx-tx,by-ty));
		}

		return result;
	}

	vector<mmBlob> appModel::SM(Mat frame, Mat foreground, vector<mmBlob> blobVect, mmBlob blobU, vector<int> indexes){
		vector<mmBlob> result;
		vector<Point> pAmb;
		vector<double> Pci, pRGB, pi;
		vector<int> depth, depthStuff, dispNum, isConteined;
		vector<bool> isBlobIntersected;
		bool isFirstMerge = false;
		bool numPci = false;
		Point minIdxPi, maxIdxPi, minIdxDepth, maxIdxDepth, minIdxDisp, maxIdxDisp;
		double minPi, maxPi, minDepth, maxDepth, minDisp, maxDisp;

		int tx = (blobU.getTL().x >= 0)?blobU.getTL().x:0;
		int ty = (blobU.getTL().y >= 0)?blobU.getTL().y:0;
		int bx = (blobU.getBR().x < frame.cols)?blobU.getBR().x:frame.cols-1;
		int by = (blobU.getBR().y < frame.rows)?blobU.getBR().y:frame.rows-1;

		for (int i=0; i<blobVect.size(); i++){
			if (blobVect[i].depth == 0){
				isFirstMerge = true;
			}
			depth.push_back(blobVect[i].depth);
			dispNum.push_back(0);
			result.push_back(mmBlob());
			isBlobIntersected.push_back(false);

			tx = (blobVect[i].getTL().x<tx)?blobVect[i].getTL().x:tx;
			ty = (blobVect[i].getTL().y<ty)?blobVect[i].getTL().y:ty;
			bx = (blobVect[i].getBR().x>bx)?blobVect[i].getBR().x:bx;
			by = (blobVect[i].getBR().y>by)?blobVect[i].getBR().y:by;
		}

		for (int i=tx; i<bx; i++){
			for (int j=ty; j<by; j++){
				Point p = Point(i,j);
				pRGB.clear();
				Pci.clear();
				pi.clear();
				isConteined.clear();

				if(isFg(foreground,p)){
					//per ogni punto da analizzare
					for (int k=0; k<blobVect.size(); k++){
						Point pOld = Point(i-blobVect[k].dispVect.x,j-blobVect[k].dispVect.y);

						 if (pOld.x < 0  || pOld.y < 0  || pOld.x > frame.cols  || pOld.y > frame.rows){
							pRGB.push_back(0);
							Pci.push_back(0);
							pi.push_back(0);
						}
						else{
							pRGB.push_back(getPrgb(frame, blobVect[k], p, pOld));
							Pci.push_back(blobVect[k].getP().at<float>(pOld.y,pOld.x));
							pi.push_back(pRGB[k]*Pci[k]);
						}
//						pRGB.push_back(getPrgb(frame, blobVect[k], p, pOld));
//						Pci.push_back(blobVect[k].getP().at<float>(pOld.y,pOld.x));
//						pi.push_back(pRGB[k]*Pci[k]);
						if (blobVect[k].isConteined(p)){
							isConteined.push_back(k);
						}
						isBlobIntersected[k] = (Pci[k] != 0)?true:isBlobIntersected[k];
					}
					if (countNonZero(Pci) > 1){
						numPci = true;
					}
//					if (totalFrameProcessed == 1056 && (Pci[0] != 0 && Pci[1] != 0)){
//						std::cout << "(x,y)=(" << i << "," << j << ")" << std::endl;
//						std::cout << "0::" << blobVect[0].centroid().x << "," << blobVect[0].centroid().y << " Pci0=" << Pci[0] << " dd::" << blobVect[0].dispVect.x << "," << blobVect[0].dispVect.y << std::endl;
//						std::cout << "1::" << blobVect[1].centroid().x << "," << blobVect[1].centroid().y << " Pci1=" << Pci[1] << " dd::" << blobVect[1].dispVect.x << "," << blobVect[1].dispVect.y << std::endl;
//					}
					minMaxLoc(pi,0,&maxPi,0,&maxIdxPi);
					//cerco in quanti blob è contenuto il punto
					if(isConteined.size() == 0){
						pAmb.push_back(p);
					}
					else if(isConteined.size() == 1){
						result[isConteined[0]].pushPoint(p);
					}
					else{
						depthStuff = depth;
						if (isFirstMerge){
							if (pi[maxIdxPi.x] != 0){
								result[maxIdxPi.x].pushPoint(p);
								dispNum[maxIdxPi.x] = dispNum[maxIdxPi.x] + 1;
							}
							else{
								pAmb.push_back(p);
							}
						}
						else{
							bool isNotAssigned = true;
							int count = 0;

							while(isNotAssigned){
								minMaxLoc(depthStuff,&minDepth,&maxDepth,&minIdxDepth,&maxIdxDepth);

								if (count < countNonZero(Pci) && pi[minIdxDepth.x] > thresh && isNotAssigned){
									result[minIdxDepth.x].pushPoint(p);
									isNotAssigned = false;
								}
								else if (count == countNonZero(Pci) && pi[minIdxDepth.x] != 0 && isNotAssigned){
									result[minIdxDepth.x].pushPoint(p);
									isNotAssigned = false;
								}
								else if (count == countNonZero(Pci) && pi[minIdxDepth.x] == 0 && isNotAssigned){
									pAmb.push_back(p);
									isNotAssigned = false;
								}
								depthStuff[minIdxDepth.x] = maxDepth+1;
								count++;
							}
						}
					}
				}
			}
		}

		//assegno punti ambigui
		for (int i=0; i<pAmb.size(); i++){
			double distCl = frame.cols;
			int index = 0;

			for (int j=0; j<blobVect.size(); j++){
				if (getDistFromCluster(frame,pAmb[i],result[j].getPointList()) < distCl){
					index = j+1;
					distCl = getDistFromCluster(frame,pAmb[i],result[j].getPointList());
				}
			}
			result[index-1].pushPoint(pAmb[i]);
		}

		for (int i=0; i<blobVect.size(); i++){
			mmBlob blobFinal;
			if (result[i].getPointList().empty()){
				blobFinal = mmBlob();
			}
			else{
				blobFinal = mmBlob(frame,result[i].getPointList());
			}
			blobFinal.setPointList(result[i].getPointList());
			blobFinal.setB(blobVect[i].getB());
			blobFinal.setG(blobVect[i].getG());
			blobFinal.setR(blobVect[i].getR());
			blobFinal.setP(blobVect[i].getP());
			result[i] = blobFinal;
		}

		int minD = 0;
		for (int i=0; i<blobVect.size(); i++){
			if (isFirstMerge && countNonZero(dispNum) && numPci){
//				std::cout << "FRAME:: " << totalFrameProcessed << std::endl;
//				std::cout << "count:: " << countNonZero(dispNum) << std::endl;
				minMaxLoc(dispNum,&minDisp,&maxDisp,&minIdxDisp,&maxIdxDisp);
				if (isBlobIntersected[maxIdxDisp.x] && dispNum[maxIdxDisp.x] > 0){
					result[maxIdxDisp.x].depth = i+1;
					dispNum[maxIdxDisp.x] = -1;
					minD = i+1;
//					std::cout << "A" << std::endl;
				}
				else if(isBlobIntersected[maxIdxDisp.x] && dispNum[maxIdxDisp.x]==0){
					result[maxIdxDisp.x].depth = minD+1;
					dispNum[maxIdxDisp.x] = -1;
//					std::cout << "B" << std::endl;
				}
				else{
					result[maxIdxDisp.x].depth = 0;
					dispNum[maxIdxDisp.x] = -1;
//					std::cout << "C" << std::endl;
				}
			}
			else{
				result[i].depth = blobVect[i].depth;

			}
			result[i].mergeDimension = blobVect[i].mergeDimension;
		}

		return result;
	}

	//	vector<mmBlob> appModel::SM(Mat frame, Mat foreground, vector<mmBlob> blobVect, mmBlob blobU, vector<int> indexes){
	//		vector<mmBlob> result;
	//		vector<Point> pAmb;
	//		vector<double> Pci, pRGB, pi;
//		vector<int> depth, depthStuff, dispNum, isConteined;
//		vector<bool> isBlobIntersected;
//		bool isFirstMerge = false;
//		Point minIdxPi, maxIdxPi, minIdxDepth, maxIdxDepth, minIdxDisp, maxIdxDisp;
//		double minPi, maxPi, minDepth, maxDepth, minDisp, maxDisp;
//
//		int tx = (blobU.getTL().x >= 0)?blobU.getTL().x:0;
//		int ty = (blobU.getTL().y >= 0)?blobU.getTL().y:0;
//		int bx = (blobU.getBR().x < frame.cols)?blobU.getBR().x:frame.cols-1;
//		int by = (blobU.getBR().y < frame.rows)?blobU.getBR().y:frame.rows-1;
//
//		for (int i=0; i<blobVect.size(); i++){
//			if (blobVect[i].depth == 0){
//				isFirstMerge = true;
//			}
//			depth.push_back(blobVect[i].depth);
//			dispNum.push_back(0);
//			result.push_back(mmBlob());
//			isBlobIntersected.push_back(false);
//
//			tx = (blobVect[i].getTL().x<tx)?blobVect[i].getTL().x:tx;
//			ty = (blobVect[i].getTL().y<ty)?blobVect[i].getTL().y:ty;
//			bx = (blobVect[i].getBR().x>bx)?blobVect[i].getBR().x:bx;
//			by = (blobVect[i].getBR().y>by)?blobVect[i].getBR().y:by;
//		}
//
//		for (int i=tx; i<=bx; i++){
//			for (int j=ty; j<=by; j++){
//				Point p = Point(i,j);
//				pRGB.clear();
//				Pci.clear();
//				pi.clear();
//				isConteined.clear();
//
//				if(isFg(foreground,p)){
//					//per ogni punto da analizzare
//					for (int k=0; k<blobVect.size(); k++){
//						Point pOld = Point(i-blobVect[k].dispVect.x,j-blobVect[k].dispVect.y);
//
//						pRGB.push_back(getPrgb(frame, blobVect[k], p, pOld));
//						Pci.push_back((double)blobVect[k].getP().at<float>(pOld.y,pOld.x));
//						pi.push_back(pRGB[k]*Pci[k]);
//						if (blobVect[k].isConteined(p)){
//							isConteined.push_back(k);
//						}
//						isBlobIntersected[k] = (Pci[k] != 0)?true:isBlobIntersected[k];
//					}
//					minMaxLoc(pi,0,&maxPi,0,&maxIdxPi);
//					//cerco in quanti blob è contenuto il punto
//					if(isConteined.size() == 0){
//						pAmb.push_back(p);
//					}
//					else if(isConteined.size() == 1){
//						result[isConteined[0]].pushPoint(p);
//					}
//					else{
//						depthStuff = depth;
//						if (isFirstMerge){
//							if (pi[maxIdxPi.x] != 0){
//								result[maxIdxPi.x].pushPoint(p);
//								dispNum[maxIdxPi.x] = dispNum[maxIdxPi.x] + 1;
//							}
//							else{
//								pAmb.push_back(p);
//							}
//						}
//						else{
//							bool isNotAssigned = true;
//							int count = 0;
//
//							while(isNotAssigned){
//								minMaxLoc(depthStuff,&minDepth,&maxDepth,&minIdxDepth,&maxIdxDepth);
//
//								if (count < countNonZero(Pci) && pi[minIdxDepth.x] > thresh && isNotAssigned){
//									result[minIdxDepth.x].pushPoint(p);
//									isNotAssigned = false;
//								}
//								else if (count == countNonZero(Pci) && pi[minIdxDepth.x] != 0 && isNotAssigned){
//									result[minIdxDepth.x].pushPoint(p);
//									isNotAssigned = false;
//								}
//								else if (count == countNonZero(Pci) && pi[minIdxDepth.x] == 0 && isNotAssigned){
//									pAmb.push_back(p);
//									isNotAssigned = false;
//								}
//								depthStuff[minIdxDepth.x] = maxDepth+1;
//								count++;
//							}
//						}
//					}
//				}
//			}
//		}
//
//		//assegno punti ambigui
//		for (int i=0; i<pAmb.size(); i++){
//			double distCl = frame.cols;
//			int index = 0;
//
//			for (int j=0; j<blobVect.size(); j++){
//				if (getDistFromCluster(frame,pAmb[i],result[j].getPointList()) < distCl){
//					index = j+1;
//					distCl = getDistFromCluster(frame,pAmb[i],result[j].getPointList());
//				}
//			}
//			result[index-1].pushPoint(pAmb[i]);
//		}
//
//		for (int i=0; i<blobVect.size(); i++){
//			mmBlob blobFinal;
//			if (result[i].getPointList().empty()){
//				blobFinal = mmBlob();
//			}
//			else{
//				blobFinal = mmBlob(frame,result[i].getPointList());
//			}
//			blobFinal.setPointList(result[i].getPointList());
//			blobFinal.setB(blobVect[i].getB());
//			blobFinal.setG(blobVect[i].getG());
//			blobFinal.setR(blobVect[i].getR());
//			blobFinal.setP(blobVect[i].getP());
//			result[i] = blobFinal;
//		}
//
//		int minD = 0;
//		for (int i=0; i<blobVect.size(); i++){
//			if (isFirstMerge && countNonZero(dispNum)){
//				minMaxLoc(dispNum,&minDisp,&maxDisp,&minIdxDisp,&maxIdxDisp);
//				if (isBlobIntersected[maxIdxDisp.x] && dispNum[maxIdxDisp.x] > 0){
//					result[maxIdxDisp.x].depth = i+1;
//					dispNum[maxIdxDisp.x] = -1;
//					minD = i+1;
//				}
//				else if(isBlobIntersected[maxIdxDisp.x] && dispNum[maxIdxDisp.x]==0){
//					result[maxIdxDisp.x].depth = minD+1;
//					dispNum[maxIdxDisp.x] = -1;
//				}
//				else{
//					result[maxIdxDisp.x].depth = 0;
//					dispNum[maxIdxDisp.x] = -1;
//				}
//			}
//			else{
//				result[i].depth = blobVect[i].depth;
//
//			}
//			result[i].mergeDimension = blobVect[i].mergeDimension;
//		}
//
//		return result;
//	}

	vector<int> blobContained(vector<mmBlob> blobVect, Point p){
		vector<int> result;

		for (int i=0; i<blobVect.size(); i++){
			if (blobVect[i].isConteined(p)){
				result.push_back(i);
			}
		}

		return result;
	}

	double getDistFromCluster(Mat frame, Point p, vector<Point> clusterP){
		double result = frame.rows*frame.cols;
		int s = clusterP.size();

		for (int i=0; i<s; i++){
			Point point = clusterP[i];
			double dist = sqrt((p.x-point.x)*(p.x-point.x) + (p.y-point.y)*(p.y-point.y));
			result = (dist<result)?dist:result;
		}

		return result;
	}

	//funziona solo con frame continui
	double appModel::getPrgb(Mat frame, mmBlob track, Point p, Point pOld){
		int in = (p.y*frame.cols + p.x);
		uchar* pr = frame.ptr<uchar>(0);

		int Bi = (int)pr[3*in];
		int Gi = (int)pr[3*in+1];
		int Ri = (int)pr[3*in+2];

		double Mb = (double)track.getB().at<float>(pOld.y,pOld.x);
		double Mg = (double)track.getG().at<float>(pOld.y,pOld.x);
		double Mr = (double)track.getR().at<float>(pOld.y,pOld.x);

		double diffB = abs(Bi-Mb)/255;
		double diffG = abs(Gi-Mg)/255;
		double diffR = abs(Ri-Mr)/255;

		double weight = sqrt(1/((2*pi*sigma*sigma)*(2*pi*sigma*sigma)*(2*pi*sigma*sigma)));
		double gauss  = exp(-(diffB*diffB+diffG*diffG+diffR*diffR)/(2*sigma*sigma));

		double pRgb = weight*gauss;
		return pRgb;
	}

	bool isFg(Mat foreground,Point p){
		bool ret = false;

		if (foreground.at<uchar>(p.y,p.x) != (uchar)0){
			ret = true;
		}
		return ret;
	}

	}
}

